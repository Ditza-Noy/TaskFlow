# circuit_breaker.py
import time
import threading
from enum import Enum
from typing import Callable, Any, Optional
from pydantic import BaseModel
import logging

logger = logging.getLogger(__name__)

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreakerConfig(BaseModel):
    failure_threshold: int = 5
    timeout_seconds: int = 60
    success_threshold: int = 3 # For half-open -> closed transition

class CircuitBreakerError(Exception):
    """Raised when circuit breaker is open."""
    pass

class CircuitBreaker:
    def __init__(self, name: str, config: CircuitBreakerConfig | None = None):
        self.name = name
        self.config = config or CircuitBreakerConfig()
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time: Optional[float] = None
        self.lock = threading.Lock()

    def _transition_to_open(self):
        self.state = CircuitState.OPEN
        self.last_failure_time = time.time()
        logger.warning("Circuit breaker transitioned to OPEN state.")

    def _transition_to_half_open(self):
        self.state = CircuitState.HALF_OPEN
        self.success_count = 0
        logger.info("Circuit breaker transitioned to HALF-OPEN state.")

    def _transition_to_closed(self):
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        logger.info("Circuit breaker transitioned to CLOSED state.")

    def call(self, func: Callable[..., Any], *args, **kwargs) -> Any:
        with self.lock:
            if self.state == CircuitState.OPEN:
                if self.last_failure_time is not None and \
                    (time.time() - self.last_failure_time) >= self.config.timeout_seconds:
                    self._transition_to_half_open()
                else:
                    raise CircuitBreakerError("Circuit breaker is OPEN.")

            try:
                result = func(*args, **kwargs)
            except Exception as e:
                self.failure_count += 1
                logger.error(f"Function call failed: {e}")
                if self.state == CircuitState.HALF_OPEN or self.failure_count >= self.config.failure_threshold:
                    self._transition_to_open()
                raise

            if self.state == CircuitState.HALF_OPEN:
                self.success_count += 1
                if self.success_count >= self.config.success_threshold:
                    self._transition_to_closed()
            else:
                self.failure_count = 0

            return result
        
    def get_state(self) -> dict[str, Any]:
        """Get current circuit breaker state."""
        return {
            'name': self.name,
            'state': self.state.value,
            'failure_count': self.failure_count,
            'success_count': self.success_count,
            'last_failure_time': self.last_failure_time
        }  
# Circuit breaker manager
class CircuitBreakerManager:
    """Manage multiple circuit breakers for different services."""
    def __init__(self):
        self.circuit_breakers: dict[str, CircuitBreaker] = {}
    def get_circuit_breaker(self, service_name: str, config: CircuitBreakerConfig | None= None) -> CircuitBreaker:
        """Get or create circuit breaker for service."""
        if service_name not in self.circuit_breakers:
            self.circuit_breakers[service_name] = CircuitBreaker(service_name, config)
        return self.circuit_breakers[service_name]
    def get_all_states(self) -> dict[str, dict[str, Any]]:
        """Get state of all circuit breakers."""
        return {name: cb.get_state() for name, cb in
        self.circuit_breakers.items()}
# Global circuit breaker manager
circuit_breaker_manager = CircuitBreakerManager()        